[{"id":1,"description":"Given:\n<code>\n2. public class Threads2 implements Runnable {\n3.\n4. public void run() {\n5. System.out.println(\"run.\");\n6. throw new RuntimeException(\"Problem\");\n7. }\n8. public static void main(String[] args) {\n9. Thread t = new Thread(new Threads2());\n10. t.start();\n11. System.out.println(\"End of method.\");\n12. }\n13.}\n</code>\nWhich two can be results? (Choose two.)\n","explaination":"The order \"Problem\" and \"End of method\" could be unpredictable because it depends on thread scheduler but the above problem will output\n\nEnd of method.\nrun.\nException in thread \"Thread-0\" java.lang.RuntimeException: Problem\nat Threads2.run(Threads2.java:5)\nat java.lang.Thread.run(Unknown Source)\n","options":[{"id":1,"text":"java.lang.RuntimeException: Problem\r\n"},{"id":2,"text":"run.\r\njava.lang.RuntimeException: Problem\r\n"},{"id":3,"text":"End of method.\r\njava.lang.RuntimeException: Problem\r\n"},{"id":4,"text":"End of method.\r\nrun.\r\njava.lang.RuntimeException: Problem\r\n"},{"id":5,"text":"run.\r\njava.lang.RuntimeException: Problem\r\nEnd of method.\r\n"}],"answer":[4,5]},{"id":2,"description":"Which two statements are true? (Choose two.)\n","explaination":"Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.Deadlock occurs when multiple threads need the same locks but obtain them in different order. A Java multithreaded program may suffer from the deadlock condition because the synchronized keyword causes the executing thread to block while waiting for the lock, or monitor, associated with the specified object. Here is an example:\ne.g.\n              <code>\n                          public void method1() {\n                                synchronized(lock1) { ...\n                                  synchronized(lock2) {\n                                   ....\n                                 }\n                          }\n                              \n                          public void method2() {\n                               synchronized(lock2) { ....\n                                  synchronized(lock1) {\n                                   ....\n                                 }\n                          }\n\n\n            </code>\nThe above code executed in multithreaded environment may lead to deadlock, because it may happen one thread has taken lock on \"lock2\" in method 2 and waiting to aquire lock on \"lock1\" which is already taken by Thread 2 while calling method1 and waiting to aquire lock2.","options":[{"id":1,"text":"It is possible for more than two threads to deadlock at once."},{"id":2,"text":"The JVM implementation guarantees that multiple threads cannot enter into a deadlocked state."},{"id":3,"text":"If a piece of code is capable of deadlocking, you cannot eliminate the possibility of deadlocking by\r\ninserting\r\ninvocations of Thread.yield().\r\n"},{"id":4,"text":"Deadlocking can occur only when the wait(), notify(), and notifyAll() methods are used incorrectly."},{"id":5,"text":"It is possible for a single-threaded application to deadlock if synchronized blocks are used incorrectly."}],"answer":[1,3]},{"id":3,"description":"Given:\n<code>\nvoid waitForSignal() {\nObject obj = new Object();\nsynchronized (Thread.currentThread()) {\nobj.wait();\nobj.notify();\n}\n}\n</code>\nWhich statement is true?\n","explaination":"The wait() method causes the current thread to wait until another thread invokes the notify() or notifyAll() method for this object.The wait, notify & notifyAll methods must be called within synchronized block or method. Note, wait, notify & notifyAll are definied inside Object class and not in Thread class. Lets find out how it works.\n\n<code>\n      synchronized(object) {\n\t   object.wait();\n      }\n</code>\nWhile executing above code by <code>Thread-1</code>, \n1. <code>Thread-1</code> holds lock on <code>object</code>.\n2. call to <code>object.wait()</code> forces <code>Thread-1</code> to release lock on object and sends the <code>Thread-1</code> into wait state.\n\n<code>\n      synchronized(object) {\n\t   object.notify();\n      }\n</code>\nWhile executing above code by <code>Thread-2</code>, \n1. <code>Thread-2</code> holds lock on <code>object</code> because <code>Thread-1</code> has released and now waiting for someone to call notify or notifyAll.\n2. call to <code>object.nofity()</code> forces <code>Thread-2</code> to release lock on object and wake up anyone from object's wait state i.e. <code>Thread-1</code>  ","options":[{"id":1,"text":"Reversing the order of obj.wait() and obj.notify() might cause this method to complete normally."},{"id":2,"text":"This code does NOT compile unless \"obj.wait()\" is replaced with \"((Thread) obj).wait()\"."},{"id":3,"text":"This code can throw an IllegalMonitorStateException."},{"id":4,"text":"A call to notify() or notifyAll() from another thread might cause this method to complete normally."},{"id":5,"text":"Code will compile and execute without any issue"}],"answer":[3]},{"id":4,"description":"What is the output if the main() method is run?\n<code>\n\n1. public class Starter extends Thread {\n2. private int x = 2;\n3. public static void main(String[] args) throws Exception {\n4. new Starter().makeItSo();\n5. }\n6. public Starter(){\n7. x = 5;\n8. start();\n9. }\n10. public void makeItSo() throws Exception {\n11. join();\n12. x = x - 1;\n13. System.out.println(x);\n14. }\n15. public void run() { x *= 2; }\n16.}\n</code>\n","explaination":"Nothing wrong with the code. It will execute properly and output 9","options":[{"id":1,"text":"Compilation fails."},{"id":2,"text":"An exception is thrown at runtime."},{"id":3,"text":"It is impossible to determine for certain."},{"id":4,"text":"9"},{"id":5,"text":"8"}],"answer":[4]},{"id":5,"description":"Given: \nWhat will be the output of below program\n<code>\npublic static void main(String[] args) {\n\t\t\n\t\ttry {\n\t\t\tSystem.exit(0);\n\t\t} catch (Error t) {\n\t\t\tSystem.out.println(\"Exception\");\n\t\t} finally {\n\t\t\tSystem.out.println(\"finally\");\n\t\t}\n\t}\n</code>","explaination":"If the JVM exits while the try or catch code is being executed, then the finally block may not execute. Likewise, if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues.\n","options":[{"id":1,"text":"Exception"},{"id":2,"text":"finally"},{"id":3,"text":"Exception\r\nfinally"},{"id":4,"text":"No output"},{"id":5,"text":"Compilation Error"}],"answer":[4]},{"id":7,"description":"Given:\n<code>\n1. public class Threads4 {\n2. public static void main (String[] args) {\n3. new Threads4().go();\n4. }\n5. public void go() {\n6. Runnable r = new Runnable() {\n7. public void run() {\n8. System.out.print(\"foo\");\n9. }\n10. };\n11. Thread t = new Thread(r);\n12. t.start();\n13. t.start();\n14. }\n15.}\n</code>\nWhat is the result?\n","explaination":"One cannot execute the same thread again once started. So calling t.start twice will throw IllegalThreadStateException.\n\nfooException in thread \"main\" java.lang.IllegalThreadStateException\nat java.lang.Thread.start(Unknown Source)\nat p6.Threads4.go(Threads4.java:15)\nat p6.Threads4.main(Threads4.java:5)\n","options":[{"id":1,"text":"Compilation fails"},{"id":2,"text":"An exception is thrown at runtime."},{"id":3,"text":"The code executes normally and prints \"foo\"."},{"id":4,"text":"The code executes normally, but nothing is printed."},{"id":5,"text":""}],"answer":[2]},{"id":8,"description":"Given:\n<code>\n1. public abstract class Shape {\n2. private int x;\n3. private int y;\n4. public abstract void draw();\n5. public void setAnchor(int x, int y) {\n6. this.x = x;\n7. this.y = y;\n8. }\n9. }\n</code>\nWhich two classes use the Shape class correctly? (Choose two.)\n","explaination":"1) One can only extend abstract class and not implement. \n2) Its not mandatory to implement all methods in Interface in an abstract class. \nso only 2 & 4 options are correct.\n","options":[{"id":1,"text":"<code>public class Circle implements Shape {\r\nprivate int radius;\r\n}\r\n</code>"},{"id":2,"text":"<code>public abstract class Circle extends Shape {\r\nprivate int radius;\r\n}\r\n</code>"},{"id":3,"text":"<code>public class Circle extends Shape {\r\nprivate int radius;\r\npublic void draw();\r\n}\r\n</code>"},{"id":4,"text":"<code>public class Circle extends Shape {\r\nprivate int radius;\r\npublic void draw() {/* code here */}\r\n}\r\n</code>"},{"id":5,"text":"<code>public abstract class Circle implements Shape {\r\nprivate int radius;\r\npublic void draw() {/* code here */}\r\n}\r\n</code>"}],"answer":[2,4]},{"id":9,"description":"Given:\n<code>\n1. public class Barn {\n2. public static void main(String[] args) {\n3. new Barn().go(\"hi\", 1);\n4. new Barn().go(\"hi\", \"world\", 2);\n5. }\n6. public void go(String... y, int x) {\n7. System.out.print(y[y.length - 1] + \" \");\n8. }\n9. }\n</code>\nWhat is the result?\n","explaination":"Compilaton will fail because the variable argument type i.e. String... shuld be last parameter in a method singnature.","options":[{"id":1,"text":"hi hi"},{"id":2,"text":"hi world"},{"id":3,"text":"world world"},{"id":4,"text":"Compilation fails."},{"id":5,"text":"An exception is thrown at runtime."}],"answer":[4]},{"id":10,"description":"Given:\n<code>\n1. class Nav{\n2. public enum Direction { NORTH, SOUTH, EAST, WEST }\n3. }\n1. public class Sprite{\n2. // insert code here\n3. }\nWhich code, inserted at line 14, allows the Sprite class to compile?\nA. Direction d = NORTH;\nB. Nav.Direction d = NORTH;\nC. Direction d = Direction.NORTH;\nD. Nav.Direction d = Nav.Direction.NORTH;\n</code>\nWhich code, inserted at line 14, allows the Sprite class to compile?","explaination":"The Direction enum defined inside Nav class and only way to access it through Nav i.e. Nav.Direction","options":[{"id":1,"text":"Direction d = NORTH;"},{"id":2,"text":"Nav.Direction d = NORTH;"},{"id":3,"text":"Direction d = Direction.NORTH;"},{"id":4,"text":"Nav.Direction d = Nav.Direction.NORTH;"},{"id":5,"text":""}],"answer":[4]},{"id":11,"description":"Which statement is true about the classes and interfaces shown below?\n<code.\n1. public interface A {\n2. public void doSomething(String thing);\n3. }\n1. public class AImpl implements A {\n2. public void doSomething(String msg) {}\n3. }\n1. public class B {\n2. public A doit(){\n3. //more code here\n4. }\n5. public String execute(){\n6. //more code here\n7. }\n8. }\n1. public class C extends B {\n2. public AImpl doit(){\n3. //more code here\n4. }\n5.\n6. public Object execute() {\n7. //more code here\n8. }\n9. }\n<code>","explaination":"The above code will fail to compile because, B.execute()'s return type String is not compatible with C.execute()'s Object return type.\nThe ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is \"close enough\" and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method that it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called a covariant return type. - oracle java doc.\n","options":[{"id":1,"text":"Compilation will succeed for all classes and interfaces."},{"id":2,"text":"Compilation of class C will fail because of an error in line 2."},{"id":3,"text":"Compilation of class C will fail because of an error in line 6."},{"id":4,"text":"Compilation of class AImpl will fail because of an error in line 2."},{"id":5,"text":""}],"answer":[3]},{"id":12,"description":"What is the result?\n<code>\n11. public class Person {\n12. String name = \"No name\";\n13. public Person(String nm) { name = nm; }\n14. }\n15.\n16. public class Employee extends Person {\n17. String empID = \"0000\";\n18. public Employee(String id) { empID = id; }\n19. }\n20.\n21. public class EmployeeTest {\n22. public static void main(String[] args){\n23. Employee e = new Employee(\"4321\");\n24. System.out.println(e.empID);\n25. }\n26. }\n</code>","explaination":"Compilation fails because there is no default constructor definied in the Person class and Employee's constructor has not invoked super(id).\nJava compiler only inserts default constructor when there are no constructors defined in the class and by default, parameterized child class constructor invokes no-argument base class constructor. To avoid compilation error introduce call to super(id) in the Employee(string) constructor. Note - call to super should be first line in the constructor code.\n<code>\npublic Employee(String id) {\nsuper(id);\nempID = id;\n}\n<code>","options":[{"id":1,"text":"4321"},{"id":2,"text":"0000"},{"id":3,"text":"An exception is thrown at runtime."},{"id":4,"text":"Compilation fails because of an error in line 18."},{"id":5,"text":""}],"answer":[4]},{"id":13,"description":"Given:\n\n1. public class Rainbow {\n2. public enum MyColor {\n3. RED(0xff0000), GREEN(0x00ff00), BLUE(0x0000ff);\n4. private final int rgb;\n5. MyColor(int rgb) { this.rgb = rgb; }\n6. public int getRGB() { return rgb; }\n7. };\n8. public static void main(String[] args) {\n9. //insert code here\n10. }\n11.}\nWhich code fragment, inserted at line 19, allows the Rainbow class to compile?\n","explaination":"Syntactically, only option 2 is correct rest has all compilation issues","options":[{"id":1,"text":"MyColor skyColor = BLUE;"},{"id":2,"text":"MyColor treeColor = MyColor.GREEN;"},{"id":3,"text":"if(RED.getRGB() < BLUE.getRGB()) { }"},{"id":4,"text":"Compilation fails due to other error(s) in the code."},{"id":5,"text":"MyColor purple = new MyColor(0xff00ff);"}],"answer":[2]},{"id":14,"description":"Given:\n<code>\n1. public class Mud {\n2. //insert code here\n3. System.out.println(\"hi\");\n4. }\n5. }\nAnd the following five fragments:\npublic static void main(String...a) {\npublic static void main(String.* a) {\npublic static void main(String... a) {\npublic static void main(String[]... a) {\npublic static void main(String...[] a) {\n</code>\nHow many of the code fragments, inserted independently at line 2, compile?\n","explaination":"Java doesnt support * and three dots in vararg variable declaration should be immediately after type name.\nbelow are the valid syntax.\npublic static void main(String...a)\npublic static void main(String... a)\npublic static void main(String...[] a)","options":[{"id":1,"text":"0"},{"id":2,"text":"1"},{"id":3,"text":"2"},{"id":4,"text":"3"},{"id":5,"text":"4"}],"answer":[4]},{"id":15,"description":"Given:\n<code>\nclass Atom {\n\tAtom() {\n\t\tSystem.out.print(\"atom \");\n\t}\n}\n\nclass Rock extends Atom {\n\tRock(String type) {\n\t\tSystem.out.print(type);\n\t}\n}\n\npublic class Mountain extends Rock {\n\tMountain() {\n\t\tsuper(\"granite \");\n\t\tnew Rock(\"granite \");\n\t}\n\n\tpublic static void main(String... ar) {\n\t\tnew Mountain();\n\t}\n}\n</code>\nWhat is the result?\n","explaination":"Code will compile and execute properly with below output\n\natom granite atom granite ","options":[{"id":1,"text":"Compilation fails."},{"id":2,"text":"atom granite"},{"id":3,"text":"granite granite"},{"id":4,"text":"atom granite atom granite "},{"id":5,"text":"An exception is thrown at runtime."}],"answer":[4]},{"id":16,"description":"Please select which of the following events will cause a thread to move from the Waiting state directly to the Runnable state?\n","explaination":"A Thread arrives in the Waiting state when it executes the wait () method on a target object / monitor. The wait () method is a method of the Object class. Every object can have a list of threads that are waiting for a notification from the object. When a Thread is waiting, it will NOT execute any further instructions until the notify () method of the target object is invoked. \n\nIf many threads are waiting on the same object, only one thread will be chosen to proceed to the Runnable state for execution when a notify () is invoked. There is no guarantee which particular thread will be invoked, as their order is NOT guaranteed. However, if there are no threads waiting when the notify () is invoked, no action will be taken. \n","options":[{"id":1,"text":"The Object.notify () method is invoked on the monitor on which the thread is waiting "},{"id":2,"text":"The start () method is invoked on the Thread object "},{"id":3,"text":"The resume () method is invoked on the Thread object "},{"id":4,"text":"The run () method is invoked on the Thread object "},{"id":5,"text":"None of the choices are correct "}],"answer":[1]},{"id":17,"description":"The class Hashtable is used to implement which collection interface. Select the one correct answer. \n","explaination":"Hashtable implements Map Interface. There is no Table interface and HashMap is a concrete class.","options":[{"id":1,"text":"Table"},{"id":2,"text":"List"},{"id":3,"text":"Map"},{"id":4,"text":"HashMap"},{"id":5,"text":"Collection"}],"answer":[3]},{"id":18,"description":"\nWhat is the default priority of a newly created thread in Hotspot JVM.\n","explaination":"A Thread inherites the priority from the parent thread. The default priority is defined in Thread class as Thread.NORM_PRIORITY. which is 5.\n","options":[{"id":1,"text":"1"},{"id":2,"text":"4"},{"id":3,"text":"10"},{"id":4,"text":"0"},{"id":5,"text":"A thread takes the priority of its parent thread."}],"answer":[5]}]